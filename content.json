{"meta":{"title":"不才才","subtitle":null,"description":"这是不才才的 hexo 博客鸭","author":"不才才","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-05-07T12:57:09.811Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[不才才] 与&nbsp; Bucaicai&nbsp; （ 不才才 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"links","date":"2020-05-07T12:20:20.000Z","updated":"2020-05-08T01:12:14.073Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"}],"posts":[{"title":"游戏人生","slug":"life","date":"2020-05-08T02:09:14.000Z","updated":"2020-05-08T04:40:03.045Z","comments":true,"path":"2020/05/08/life/","link":"","permalink":"/2020/05/08/life/","excerpt":"","text":"视频出处：Bilibili 甘樂Ganre_ 近年来史上最催泪游戏，让无数玩家感悟人生的游戏神作？","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"life","slug":"life","permalink":"/tags/life/"},{"name":"game","slug":"game","permalink":"/tags/game/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"快速幂运算","slug":"fast-power","date":"2020-03-28T05:26:19.000Z","updated":"2020-05-08T04:09:52.494Z","comments":true,"path":"2020/03/28/fast-power/","link":"","permalink":"/2020/03/28/fast-power/","excerpt":"","text":"幂运算幂运算，即次方运算，通常我们会使用连乘来实现次方运算，但是往往效率不高，时间复杂度接近 O(n)。 public static int power(int a, int b){ int ans = 1; while(b--){ ans *= a; } return ans; } 快速幂原理通过将指数拆分成几个因数相乘的形式，来简化幂运算 以 5 的 9 次方为例： 将 9 写成二进制形式：1001 59 = 5(1 23 + 0 22 + 0 21+ 1 20) 利用位运算里的位移 “&gt;&gt;” 和按位与 “&amp;” 运算, 截取指数的二进制最低位判断是否需要乘，依次循环截取。对于 9 来说，二进制是 1001，有 4 位，就只需要计算 4 次，快速幂算法时间复杂度是 O(logn) 级别 b &amp; 1 其实就是取 b 二进制的最低位，用来判断最低位是0还是1，再根据是 0 还是 1 决定乘不乘 b &gt;&gt;= 1 将 b 的二进制向右移动一位 快速幂实现/** * 快速幂计算 * @param a 底数 * @param b 指数 * @param mod 取模常数 * @return */ public static long kms(long a, long b, long mod){ long ans = 1, res = a; while(b != 0) { if((b &amp; 1) != 0) { ans = ans * res % mod; } b &gt;&gt;= 1; res = res * res % mod; } return ans % mod; }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"快速幂","slug":"快速幂","permalink":"/tags/快速幂/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"生产者消费者","slug":"producer-customer","date":"2020-03-28T04:43:30.000Z","updated":"2020-05-08T04:05:44.534Z","comments":true,"path":"2020/03/28/producer-customer/","link":"","permalink":"/2020/03/28/producer-customer/","excerpt":"","text":"生产者消费者模式生产者生产数据到缓冲区中，消费者从缓冲区中取数据。如果缓冲区已经满了，则生产者线程阻塞；如果缓冲区为空，那么消费者线程阻塞 资源class Resource { int id; public Resource(int id) { this.id = id; } } 生产者线程class Producer extends Thread { int p = 1; @Override public void run() { while (true) { try { Resource resource = new Resource(p++); System.out.println(&quot;生产资源&quot; + resource.id); ProducerConsumer.queue.put(resource); } catch (InterruptedException e) { e.printStackTrace(); } } } } 消费者线程class Consumer extends Thread { @Override public void run() { while (true) { try { Resource resource = ProducerConsumer.queue.take(); System.out.println(&quot;消费资源&quot; + resource.id); } catch (InterruptedException e) { e.printStackTrace(); } } } } 测试类public class ProducerConsumer { // 阻塞队列 public static BlockingQueue queue = new LinkedBlockingQueue&lt;Resource&gt;(10); public static void main(String[] args) { Producer producer = new Producer(); //生产者 Consumer consumer1 = new Consumer(); //消费者1 Consumer consumer2 = new Consumer(); //消费者2 Consumer consumer3 = new Consumer(); //消费者3 producer.start(); consumer1.start(); consumer2.start(); consumer3.start(); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"},{"name":"生产者消费者","slug":"生产者消费者","permalink":"/tags/生产者消费者/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"top-k","slug":"top-k","date":"2020-03-28T04:30:36.000Z","updated":"2020-05-08T04:31:36.948Z","comments":true,"path":"2020/03/28/top-k/","link":"","permalink":"/2020/03/28/top-k/","excerpt":"","text":"TopK 问题数组中的第K个最大元素在未排序的数组中找到第 k 个最大的元素。 示例 : 输入: [3, 2, 1, 5, 6, 4] 和 k = 2 输出: 5 堆：维护一个大小为 K 的最小堆, 最小堆中的元素就是第 K 大元素。 public int findKthLargest(int[] nums, int k) { // 一个基于优先级的无界优先级队列, 按照自然规律排序 PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;(); for (int n: nums) { heap.offer(n); if (heap.size() &gt; k) // 保持第K大元素在队列顶部 heap.poll(); } return heap.poll(); } 快速选择：第 K 个元素的问题, 可以使用快速排序实现。 public int findKthLargest(int[] nums, int k) { int l = 0; int h = nums.length - 1; k = nums.length + 1 - k; //第 k 大 == 第 n + 1 - k 小 while(l &lt; h){ int pos = partition(nums, l, h); if(pos == k - 1){ break; } else if(pos &lt; k - 1) { l = pos + 1; } else { h = pos - 1; } } return nums[k - 1]; } private int partition(int[] arr, int left, int right) { // 设定基准值（pivot） int pivot = arr[left]; int i = left; int j = right; while(i &lt; j) { // 从右向左找小于x的数来填s[i] while(i &lt; j &amp;&amp; s[j] &gt;= x) { j--; } if(i &lt; j) { s[i] = s[j]; //将s[j]填到s[i]中, s[j]就形成了一个新的坑 i++; } // 从左向右找大于或等于x的数来填s[j] while(i &lt; j &amp;&amp; s[i] &lt; x) { i++; } if(i &lt; j) { s[j] = s[i]; //将s[i]填到s[j]中, s[i]就形成了一个新的坑 j--; } } arr[i] = pivot; return i; } 前 K 个高频元素给定一个非空的整数数组, 返回其中出现频率前 k 高的元素。 示例 : 输入: nums = [1, 1, 1, 2, 2, 3], k = 2 输出: [1, 2] 思路：设置若干个桶, 每个桶存储出现频率相同的数。桶的下标表示数出现的频率, 即第 i 个桶中存储的数出现的频率为 i。 把数都放到桶之后, 从后向前遍历桶, 最先得到的 k 个数就是出现频率最多的的 k 个数 public List&lt;Integer&gt; topKFrequent(int[] nums, int k) { //用于计数的map HashMap&lt;Integer, Integer&gt; count = new HashMap&lt;Integer, Integer&gt;(); for(int num : nums) { //初始化每个元素出现的频率 count.put(num, count.getOrDefault(num, 0) + 1); } //构建大顶堆 PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; count.get(n1) - count.get(n2)); for (int n : count.keySet()) { heap.add(n); if (heap.size() &gt; k) { heap.poll(); } } List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); while(!heap.isEmpty()) { result.add(heap.poll()); } Collections.reverse(result); //反转 return result; }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"Top K","slug":"Top-K","permalink":"/tags/Top-K/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"二叉树遍历","slug":"binary-tree","date":"2020-03-28T04:25:16.000Z","updated":"2020-05-08T04:08:13.744Z","comments":true,"path":"2020/03/28/binary-tree/","link":"","permalink":"/2020/03/28/binary-tree/","excerpt":"","text":"二叉树二叉树是每个结点最多有两个子树的树结构，二叉树常被用于实现二叉查找树和二叉堆 定义树节点结构private static class TreeNode&lt;T&gt;{ T val; TreeNode left; TreeNode right; TreeNode(T val){ this.val = val; } } 创建二叉树 public static TreeNode creatBinaryTree(LinkedList&lt;T&gt; list){ TreeNode root = null; if(list == null || list.isEmpty()) { reutrn root; } T val = list.removeFirst(); if(val != null) { root = new TreeNode(val); root.left = creatBinaryTree(list); root.right = creatBinaryTree(list); } return root; } 前序遍历按照 根-左-右 顺序递归遍历 public void preOrder(TreeNode root) { if(root == null) { return; } System.out.println(root.val); preOrder(root.left); preOrder(root.right); } 中序遍历public void inOrder(TreeNode root) { if(root == null) { return; } preOrder(root.left); System.out.println(root.val); preOrder(root.right); } 后序遍历public void postOrder(TreeNode root) { if(root == null) { return; } preOrder(root.left); preOrder(root.right); System.out.println(root.val); } 二叉树遍历非递归实现非递归使用最多的数据结构就是栈，栈具有先天的递归特性，以前序遍历为例： public void preOrder(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode node = root; while(node != null || !stack.isEmpty()) { // 左孩子入栈 while(node != null) { System.out.println(node.val); stack.push(node); node = node.left; } //左孩子为空, 弹出栈顶, 访问右孩子 if(!stack.isEmpty()) { node = stack.pop(); node = node.right; } } } 二叉树的层序遍历public void levelOrder(TreeNode root) { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty()) { TreeNode node = queue.poll(); System.out.println(node.val); // 左孩子入队列 if(node.left != null) { queue.offer(node.left); } if(node.right != null) { queue.offer(node.right); } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"单例模式","slug":"singleton","date":"2020-03-28T04:19:28.000Z","updated":"2020-05-08T04:03:34.176Z","comments":true,"path":"2020/03/28/singleton/","link":"","permalink":"/2020/03/28/singleton/","excerpt":"","text":"单例模式属于创建型设计模式，单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点 单例性质 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 常见实现 懒汉式，线程不安全 public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 懒汉式，线程安全 public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉式 public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 双重校验锁 public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 双重校验锁 volatitle 的作用 禁止指令重排序 ：new Singleton() 是一个非原子操作，编译器可能会重排序，即赋值操作在初始化对象前完成。而线程 B 在线程 A 赋值完时判断 instance 就不为 null 了，此时 B 拿到的将是一个没有初始化完成的半成品。 保证可见性：线程 A 在自己的工作线程内创建了实例，但此时还未同步到主存中；此时线程 B 在主存中判断 instance 还是 null ，那么线程 B 又将在自己的工作线程中创建一个实例，这样就创建了多个实例。 Spring中的单例模式的应用Spring 中加载单例的过程都是在 BeanFactory 接口中定义的 getBean 方法 private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256); protected Object getSingleton(String beanName, boolean allowEarlyReference) { //通过名字查找这个单例bean是否存在 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) { synchronized (this.singletonObjects) { //查看缓存中是否存在这个bean实例 singletonObject = this.earlySingletonObjects.get(beanName); //如果这个时候的bean实例还是为空并且允许懒加载 if (singletonObject == null &amp;&amp; allowEarlyReference) { ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } return singletonObject; }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"/tags/单例模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"时间复杂度","slug":"time-complexity","date":"2020-03-27T08:33:09.000Z","updated":"2020-05-08T04:01:30.995Z","comments":true,"path":"2020/03/27/time-complexity/","link":"","permalink":"/2020/03/27/time-complexity/","excerpt":"","text":"面试中的复杂度分析 很多同学一提起复杂度分析就头疼，马上想起了《算法导论》中复杂的数学推导。但其实在一般的企业面试中，对复杂度的分析要求并没有那么高，但也是绕不过去的坎儿。 2-1 究竟什么是大O（Big O）O(f(n)) 表示算法所执行的指令数和 f(n) 成正比, 表示算法执行的上界（最低） 二分查找 O(logn) 寻找数组中的最大/最小值 O(n) 归并排序算法 O(nlogn) 选择排序 O(n^2) O（AlogA + B） 不能相互替换，A，B都与算法相关 例：有一个字符串数组,将数组中的每一个字符串按照字母序排序;之后再将整个字符串数组按照字典序排序。整个操作的时间复杂度 ? 分析：假设最长的字符串长度为 s ; 数组中有 n 个字符串 对每个字符串排序: O(slogs) 将数组中的每一个字符串按照字母序排序: O(n*slog(s)) 将整个字符串数组按照字典序排序: O(s*nlog(n)) O(n*slog(s)) + O(s*nlog(n)) = O(n*s*logs+s*n*logn) = O(n*s*(logs+logn)) 2-2 对数据规模有一个概念public static void main(String[] args) throws Exception { for (int x = 1; x &lt; 10; x++) { int n = (int) Math.pow(10, x); long start = System.currentTimeMillis(); int sum = 0; for (int i = 0; i &lt; n; i++) { sum += i; } long end = System.currentTimeMillis(); System.out.println(&quot;10^&quot; + x + &quot;:&quot; + (end - start) + &quot;ms&quot;); } } 如果要想在1s之内解决问题: O(n^2) 的算法可以处理大约 10^4 级别的数据; O(n) 的算法可以处理大约 10^8 级别的数据; O(nlogn) 的算法可以处理大约 10^7 级别的数据 2-3 简单的复杂度分析// O(1) void swap(int a, int b) { int temp = a; a = b; b = temp; } // O(n) void reverse(String s) { int n = s.length(); for(int i = 0; i &lt; n/2; i++) swap(s[i], s[n-1-1]); } // O(n^2) void selectSort(int arr[], int n) { for(int i = 0; i &lt; n; i++) { int minIndex = i; for(int j = i + 1; j &lt; n; j++){ if(arr[j] &lt; arr[minTndex]) minIndex = j; } swap(arr[i], arr[minIndex]); } } // O(logn) // 分析：每次折半查找， n 经过几次除以 2 后等于 1 ？ int binarySearch(int arr[], int n,int target) { int l = 0, r = n-1; while(l &lt;= r) { int mid = l + (r-l)/2; if(arr[mid] == target) return mid; if(arr[mid] &gt; target) r = mid - 1; else l = mid + 1; } return -1; } // 分析：n经过几次除以 10 操作后等于 0 ? String intToString(int num) { String s = &quot;&quot;; while(num) { s += &#39;0&#39; + num % 10; num /= 10; } reverse(s); return s; } // O(sqrt(n)) boolean isPrime(int n) { if(n == 0 || n == 1 || n &lt; 0) return false; for(int x = 2; x*x &lt;= n; x++){ if(n % x == 0) return false; } return false; } // O(nlogn) void hello(int n) { for(int i = 1; i &lt; n; i+=i) { //每次 * 2 for(int j = 1; j &lt; n; j++) ... } 2-4 复杂度实验每次将数据规模翻倍，查看测试的时间： O(n) : 测试时间扩大 2 倍 O(n^2) : 测试时间扩大 4 倍 O(logn) : 测试时间几乎不变 O(nlogn) : 测试时间扩大 2 倍多 2-5 递归算法的复杂度分析不是有递归的函数就一定是O(nlongn)！ 如果递归函数中,只进行一次递归调用,递归深度为 depth ;在每个递归函数中,时间复杂度为 T ，则总体的时间复杂度为 O(Tdepth) 递归中进行一次递归调用的复杂度分析 int sum(int n) { assert(n &gt;= 0); if(n == 0) return 0; return n + sum(n - 1);//递归深度：n;时间复杂度：O(n) } double pow(double x, int n) { assert(n &gt;= 0); if(n == 0) return 1.0; double t = pow(x, n/2); // 递归深度 logn 时间复杂度O(logn) if(n % 2) return x*t*t; return t*t; } 递归中进行多次递归调用的复杂度分析 int f(int n) { assert(n &gt;= 0); if(n == 0) return 1; return f(n - 1)+f(n - 1); } 分析：使用递归树分析调用的次数（递归树节点数） 分治，每层都是这 n 个数据，递归树深度为 logn 2-6 均摊时间复杂度分析（Amortized Time Analysis） 动态数组的实现 template &lt;typename T&gt; class Vector { private: T* data; int capacity; //容量 int size; //大小 // O(n) void resize(int newCapacity){ assert(newCapacity &gt;= size); T *newData = new T[newCapacity]; for(int i = 0; i &lt; size; i++) { newData[i] = data[i]; } delete[] data; data = newData; capacity = newCapacity; } public: Vecotr(){ data = new T[10]; capacity = 10; size = 0; } ~Vector(){ delete[] data; } //均摊复杂度下依然是O(1) // resize 的条件是在数组长度达到capacity时才会发生 //重新赋值遍历次数size(capacity) //均摊到每个元素相当于耗费O(1) void push(T e){ //assert(size &lt; capacity); if(size == capacity) resize(2 * capacity); data[size++] = e; } T pop(){ assert(size &gt; 0); T ret = data[size-1]; size--; //修改为1/4留有余地 if(size == capacity/4) resize(capacity/2); return data[size]; } }; 2-7 避免复杂度的震荡当重复增删1/2处元素时，会出现数组振荡问题，即：多次resize造成的数组不停的改变容量，重复这个过程,无法均摊，复杂度为O(n) 解决方法：当元素个数为数组容量的 1/4 时 resize 为原来的 1/2，保留余地。 类似的动态数组，动态栈，动态队列同样存在均摊。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"时间复杂度","slug":"时间复杂度","permalink":"/tags/时间复杂度/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}